module Main exposing (main)

import Bytes exposing ( Bytes )
import Bytes.Decode
import Bytes.Encode
import ChildProcess
import FileSystem exposing (AccessError(..))
import Node
import Init
import Prettynice.Props as Props exposing (Props)
import Set
import Shikensu
import Shikensu.Contrib as Shikensu
import Shikensu.Bundle as Shikensu
import Shikensu.Definition as Shikensu
import Shikensu.Error as Error exposing (Error(..))
import Shikensu.Focus as Shikensu exposing ( Focus(..) )
import Shikensu.Focus
import Shikensu.Path as Path
import Stream
import Task exposing (Task)


main : Shikensu.Program
main =
    let
        collection =
            [ { focus = componentSource
              , sequence = clientComponentSequence
              }
            , { focus = componentSource
              , sequence = clientPortsSequence
              }
            , { focus = componentSource
              , sequence = serverComponentSequence
              }
            , { focus = serverSource
              , sequence = serverPortsSequence
              }
            , { focus = publicAssetsSource
              , sequence = publicAssetsSequence
              }
            ]
    in
    -- replace this with your own function that can init ChildProcess
    perform
        { onSuccess = 
            ( \env _ -> Stream.sendLine env.stdout "âœ… Done!" )
        , onError =
            ( \env err ->
                Cmd.batch
                    [ Stream.sendLine env.stderr ("ðŸš¨ " ++ Error.toString err)
                    , Node.setExitCode 1
                    ]
            )
        }
        (\fsPermission procPermission ->
            collection
                |> Array.map
                        (\{ focus, sequence } ->
                            focus
                                |> Shikensu.list fsPermission
                                |> Task.onError
                                    (\error -> 
                                        case error of
                                            PlatformAccessError _ AccessErrorNotFound ->
                                                -- Nothing to process. Ignore.
                                                -- (e.g. no components or nothing at public/)
                                                Task.succeed 
                                                    (emptyBundle fsPermission)

                                            e ->
                                                Task.fail e
                                    )
                                |> sequence procPermission
                        )
                |> Task.sequence
        )


perform :
    { onSuccess : Node.Environment -> a -> Cmd {}
    , onError : Node.Environment -> Error -> Cmd {}
    }
    -> (FileSystem.Permission -> ChildProcess.Permission -> Task Error a)
    -> Shikensu.Program
perform errorHandling taskCreator =
    Node.defineSimpleProgram <| \env ->
        Init.await FileSystem.initialize <| \fsPermission ->
            Init.await ChildProcess.initialize <| \procPermission ->
                procPermission
                    |> taskCreator fsPermission
                    |> Task.andThen (errorHandling.onSuccess env >> Task.succeed)
                    |> Task.onError (errorHandling.onError env >> Task.succeed)
                    |> (\t -> Init.awaitTask t Node.endWithCmd)


emptyBundle : FileSystem.Permission -> Shikensu.Bundle
emptyBundle permission =
    { compendium = []
    , fsPermission = permission
    , readingDirectory = Nothing
    , workingDirectory = Path.directory ["."]
    }


componentSource : Shikensu.Focus
componentSource =
    [ "client", "src", "Components" ]
        |> Path.directory
        |> Relative


publicAssetsSource : Shikensu.Focus
publicAssetsSource =
    [ "public" ]
        |> Path.directory
        |> Relative


serverSource : Shikensu.Focus
serverSource =
    [ "server", "src" ]
        |> Path.directory
        |> Relative


serverDestination : Shikensu.Focus
serverDestination =
    [ "server", ".prettynice", "Gen", "Components" ]
        |> Path.directory
        |> Relative


clientDestination : Shikensu.Focus
clientDestination =
    [ "client", ".prettynice", "Gen", "Components" ]
        |> Path.directory
        |> Relative


clientPortsDestination : Shikensu.Focus
clientPortsDestination =
    [ "dist", "client", "Components" ]
        |> Path.directory
        |> Relative


serverPortsDestination : Shikensu.Focus
serverPortsDestination =
    [ "dist", "server" ]
        |> Path.directory
        |> Relative


publicAssetsDestination : Shikensu.Focus
publicAssetsDestination =
    [ "dist", "client" ]
        |> Path.directory
        |> Relative


readGrenFiles : Shikensu.Task -> Shikensu.Task
readGrenFiles task =
     task
        |> Task.map (Shikensu.withExtension "gren")
        |> Task.andThen Shikensu.read


serverComponentSequence : ChildProcess.Permission -> Shikensu.Task -> Shikensu.Task
serverComponentSequence _ task =
    task
        |> readGrenFiles
        |> Task.andThen genServerComponent
        |> Task.andThen (Shikensu.write serverDestination)


clientComponentSequence : ChildProcess.Permission -> Shikensu.Task -> Shikensu.Task
clientComponentSequence procPermission task =
    task
        |> readGrenFiles
        |> Task.map (Shikensu.renderContent clientComponentFromDef)
        |> Task.andThen (Shikensu.write clientDestination)
        |> Task.andThen (buildClientComponents procPermission)


buildClientComponents : ChildProcess.Permission -> Shikensu.Bundle -> Shikensu.Task
buildClientComponents procPermission bundle =
    let
        inputs =
            bundle.compendium
                -- TODO: test. then refactor and add comments!
                |> Array.map
                    (\def ->
                        Path.combine
                            (Path.combine
                                bundle.workingDirectory
                                (Path.combine
                                    (Path.directory [ "client", ".prettynice", "Gen", "Components" ])
                                    (def.directoryPath)
                                )
                            )
                            (Path.file [ def.baseName ++ ".gren" ])
                                |> Path.toPosix { absolute = True }
                    )

        outputPath =
                Path.combine
                    bundle.workingDirectory
                    -- TODO: remove duplication
                    (Path.file [ "dist", "client", "main.js" ])
                        |> Path.toPosix { absolute = True }

        workingDirectory =
            Path.combine
                bundle.workingDirectory
                (Path.directory [ "client" ])
                    |> Path.toPosix { absolute = True }
        
        runOptions =
            { ChildProcess.defaultRunOptions
                | workingDirectory =
                    ChildProcess.SetWorkingDirectory
                        workingDirectory
            }
    in
    if inputs == [] then
        Task.succeed bundle
    else
        ChildProcess.run
            procPermission
            "gren"
            ([ "make" ] ++ inputs ++ [ "--output", outputPath ])
            runOptions
                |> Task.mapError 
                    (\e -> 
                        e.stderr
                            |> toString
                            |> Maybe.withDefault "Failed to compile components"
                            |> ErrorMessage
                    )
                |> Task.andThen (\_ -> Task.succeed bundle)


{-| For every component, clone the corresponding js ports file if it exists.
    Otherwise create an empty one.
-}
clientPortsSequence : ChildProcess.Permission -> Shikensu.Task -> Shikensu.Task
clientPortsSequence _ task =
    task
        |> Task.map (Shikensu.withExtension "gren")
        |> Task.map (Shikensu.renameExtension "gren" "js")
        |> Task.andThen
            (\bundle ->
                Task.onError
                    (\_ -> Task.succeed bundle)
                    (Shikensu.read bundle)
            )
        |> Task.andThen (Shikensu.write clientPortsDestination)


{-| Clone the server js ports file if it exists.
    Otherwise create an empty one.
-}
serverPortsSequence : ChildProcess.Permission -> Shikensu.Task -> Shikensu.Task
serverPortsSequence _ task =
    task
        |> Task.map (Shikensu.withExtension "js")
        |> Task.map (Shikensu.withBaseName "ports")
        |> Task.andThen
            (\bundle ->
                Task.onError
                    (\_ -> Task.succeed bundle)
                    (Shikensu.read bundle)
            )
        |> Task.andThen (Shikensu.write serverPortsDestination)


{-| Copy public assets.
-}
publicAssetsSequence : ChildProcess.Permission -> Shikensu.Task -> Shikensu.Task
publicAssetsSequence _ task =
    task
        |> Task.andThen Shikensu.read
        |> Task.andThen (Shikensu.write publicAssetsDestination)


clientComponentFromDef : Shikensu.Definition -> Maybe Bytes
clientComponentFromDef def =
    def.content
        |> Maybe.andThen toString
        |> Maybe.map (toClientComponent def)
        |> Maybe.map toBytes


toString : Bytes -> Maybe String
toString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


toBytes : String -> Bytes
toBytes string =
    string
        |> Bytes.Encode.string
        |> Bytes.Encode.encode


toClientComponent : Shikensu.Definition -> String -> String
toClientComponent def contents =
    """
    module Gen.{{MODULE_NAME}} exposing (main)

    import Transmutable.Html.VirtualDom exposing (toVirtualDom)
    import {{MODULE_NAME}} as {{NAME}}
    import Browser

    main : Program {{NAME}}.Props {{NAME}}.Model {{NAME}}.Msg
    main =
        let
            e = {{NAME}}.component
        in
        Browser.element
            { init = e.init
            , update = e.update
            , subscriptions = e.subscriptions
            , view = e.view >> toVirtualDom
            }
    """
        |> String.replace "{{NAME}}" def.baseName
        |> String.replace "{{MODULE_NAME}}" (moduleName def)


moduleName : Shikensu.Definition -> String
moduleName def =
    let
        path =
            Path.unwrap def.directoryPath

        modulePath =
            case path of
                [] ->
                    "Components."

                dirs ->
                    "Components."
                        ++ (String.join "." dirs)
                        ++ "."
    in
    modulePath ++ def.baseName


genServerComponent : Shikensu.Bundle -> Task Error Shikensu.Bundle
genServerComponent bundle =
    let
        newBundle =
            bundle
                |> Shikensu.mapCompendium
                    ( Array.map
                        ( \def ->
                            let
                                content =
                                    def.content
                                        |> Maybe.andThen toString
                                        |> Maybe.withDefault ""

                                propsResult =
                                    Props.get content
                            in
                            { def
                                | content =
                                    case propsResult of
                                        Ok props ->
                                            toServerComponent def props
                                                |> toBytes
                                                |> Just

                                        e ->
                                            Nothing
                            }
                        )
                    )
        
        badDef =
            newBundle.compendium
                |> Array.findFirst
                    (\def -> def.content == Nothing)
    in
    case badDef of
        Nothing ->
            Task.succeed newBundle
        
        Just def ->
            Task.fail
                ( ErrorMessage <|
                    String.replace "{{COMPONENT}}" def.baseName
                        """
                        Oops! I can't parse props for the {{COMPONENT}} component.
                           I'm looking for a type alias that looks like this:

                                type alias Props =
                                    { myField : String
                                    , myOtherField : Int
                                    }

                           It either doesn't exist, is formatted in a way I
                           can't recognize, or it uses unsupported field types.
                           See Prettynice.Props.Fieldtype for supported types:
                           https://github.com/blaix/prettynice/blob/main/src/Prettynice/Props.gren
                        """
                )


toServerComponent : Shikensu.Definition -> Props -> String
toServerComponent def props =
    """
    module Gen.{{MODULE_NAME}} exposing (init)

    import Json.Encode as Encode
    import Prettynice.Props as Props
    import Transmutable.Html as H exposing (Html)
    import Transmutable.Html.Attributes as A

    type alias Props =
        {{PROPS_TYPE}}

    encoder : Props -> Encode.Value
    encoder props =
        {{PROPS_ENCODER}}

    init : Props -> Html msg
    init props =
        let
            propJson = Encode.encode 0 (encoder props)
        in
        H.span []
            [ H.span [ A.class "prettynice-component-{{MODULE_NAME}}" ] []
            , H.node "script" []
                [ H.text <|
                    \"""
                    var $__components = $__components || {};
                    $__components["{{MODULE_NAME}}"] = $__components["{{MODULE_NAME}}"] || [];
                    $__components["{{MODULE_NAME}}"].push(
                        Gren.Gen.{{MODULE_NAME}}.init({
                            node: document.currentScript.parentNode.getElementsByClassName("prettynice-component-{{MODULE_NAME}}")[0],
                            flags: \""" ++ propJson ++ \""",
                        })
                    );
                    \"""
                ]
            ]
    """
        |> String.replace "{{MODULE_NAME}}" (moduleName def)
        |> String.replace "{{PROPS_TYPE}}" (Props.typeSig props)
        |> String.replace "{{PROPS_ENCODER}}" (Props.encoder props)
