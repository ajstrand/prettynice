module Main exposing (main)

import Bytes exposing ( Bytes )
import Bytes.Decode
import Bytes.Encode
import Node
import Prettynice.Props as Props exposing (Props)
import Set
import Shikensu
import Shikensu.Contrib as Shikensu
import Shikensu.Bundle as Shikensu
import Shikensu.Definition as Shikensu
import Shikensu.Error as Error exposing (Error(..))
import Shikensu.Focus as Shikensu exposing ( Focus(..) )
import Shikensu.Focus
import Shikensu.Path as Path
import Stream
import Task exposing (Task)


main : Shikensu.Program
main =
    let
        collection =
            [ { focus = source
              , sequence = clientSequence
              }
            , { focus = source
              , sequence = clientPortsSequence
              }
            , { focus = source
              , sequence = serverSequence
              }
            ]
    in
    Shikensu.perform
        { onSuccess = 
            ( \env _ -> Stream.sendLine env.stdout "ðŸ§ª Sequence completed" )
        , onError =
            ( \env err ->
                Cmd.batch
                    [ Stream.sendLine env.stderr ("ðŸš¨ " ++ Error.toString err)
                    , Node.setExitCode 1
                    ]
            )
        }
        (\fsPermission ->
            collection
                |> Array.map
                        (\{ focus, sequence } ->
                            focus
                                |> Shikensu.list fsPermission
                                |> sequence
                        )
                |> Task.sequence
        )


source : Shikensu.Focus
source =
    [ "client/src/Components"
    ]
        |> Path.directory
        |> Relative


serverDestination : Shikensu.Focus
serverDestination =
    [ "server/gen/Gen/Components"
    ]
        |> Path.directory
        |> Relative


clientDestination : Shikensu.Focus
clientDestination =
    [ "client/gen/Gen/Components"
    ]
        |> Path.directory
        |> Relative


clientPortsDestination : Shikensu.Focus
clientPortsDestination =
    [ "dist/client"
    ]
        |> Path.directory
        |> Relative


readFiles : Shikensu.Task -> Shikensu.Task
readFiles task =
     task
        |> Task.map (Shikensu.withExtension "gren")
        |> Task.andThen Shikensu.read


serverSequence : Shikensu.Task -> Shikensu.Task
serverSequence task =
    task
        |> readFiles
        |> Task.andThen genServerComponent
        |> Task.andThen (Shikensu.write serverDestination)


clientSequence : Shikensu.Task -> Shikensu.Task
clientSequence task =
    task
        |> readFiles
        |> Task.map (Shikensu.renderContent clientComponentFromDef)
        |> Task.andThen (Shikensu.write clientDestination)


{-| For every component, clone the corresponding js ports file if it exists.
    Otherwise create an empty one.
-}
clientPortsSequence : Shikensu.Task -> Shikensu.Task
clientPortsSequence task =
    task
        |> Task.map (Shikensu.withExtension "gren")
        |> Task.map (Shikensu.renameExtension "gren" "js")
        |> Task.andThen
            (\bundle ->
                Task.onError
                    (\_ -> Task.succeed bundle)
                    (Shikensu.read bundle)
            )
        |> Task.andThen (Shikensu.write clientPortsDestination)


clientComponentFromDef : Shikensu.Definition -> Maybe Bytes
clientComponentFromDef def =
    def.content
        |> Maybe.andThen toString
        |> Maybe.map (toClientComponent def)
        |> Maybe.map toBytes


toString : Bytes -> Maybe String
toString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


toBytes : String -> Bytes
toBytes string =
    string
        |> Bytes.Encode.string
        |> Bytes.Encode.encode


toClientComponent : Shikensu.Definition -> String -> String
toClientComponent def contents =
    """
    module Gen.Components.{{NAME}} exposing (main)

    import Transmutable.Html.VirtualDom exposing (toVirtualDom)
    import Components.{{NAME}} as {{NAME}}
    import Browser

    main =
        let
            e = {{NAME}}.component
        in
        Browser.element
            { init = e.init
            , update = e.update
            , subscriptions = e.subscriptions
            , view = e.view >> toVirtualDom
            }
    """
        |> String.replace "{{NAME}}" def.baseName


genServerComponent : Shikensu.Bundle -> Task Error Shikensu.Bundle
genServerComponent bundle =
    let
        newBundle =
            bundle
                |> Shikensu.mapCompendium
                    ( Array.map
                        ( \def ->
                            let
                                content =
                                    def.content
                                        |> Maybe.andThen toString
                                        |> Maybe.withDefault ""

                                propsResult =
                                    Props.get content
                            in
                            { def
                                | content =
                                    case propsResult of
                                        Ok props ->
                                            toServerComponent def.baseName props
                                                |> toBytes
                                                |> Just

                                        e ->
                                            Nothing
                            }
                        )
                    )
        
        badDef =
            newBundle.compendium
                |> Array.findFirst
                    (\def -> def.content == Nothing)
    in
    case badDef of
        Nothing ->
            Task.succeed newBundle
        
        Just def ->
            Task.fail
                ( ErrorMessage <|
                    String.replace "{{COMPONENT}}" def.baseName
                        -- TODO: improve error message
                        """
                        Oops! I can't find props for the {{COMPONENT}} component.
                           I'm looking for a type alias that looks like this:

                                type alias Props =
                                    { myField : String
                                    , myOtherField : Int
                                    }

                           It either doesn't exist, is formatted in a way I
                           can't recognize, or it uses unsupported field types.
                           TODO: link to documentation for this.\n
                        """
                )


toServerComponent : String -> Props -> String
toServerComponent name props =
    """
    module Gen.Components.{{NAME}} exposing (init)

    import Json.Encode as Encode
    import Prettynice.Props as Props
    import Transmutable.Html as H exposing (Html)
    import Transmutable.Html.Attributes as A

    type alias Props =
        {{PROPS_TYPE}}

    encoder : Props -> Encode.Value
    encoder props =
        {{PROPS_ENCODER}}

    init : Props -> Html msg
    init props =
        let
            propJson = Encode.encode 0 (encoder props)
        in
        H.span []
            [ H.span [ A.class "prettynice-component-{{NAME}}" ] []
            , H.node "script" []
                [ H.text <|
                    \"""
                    var $__components = $__components || {};
                    $__components["{{NAME}}"] = $__components["{{NAME}}"] || [];
                    $__components["{{NAME}}"].push(
                        Gren.Gen.Components.{{NAME}}.init({
                            node: document.currentScript.parentNode.getElementsByClassName("prettynice-component-{{NAME}}")[0],
                            flags: \""" ++ propJson ++ \""",
                        })
                    );
                    \"""
                ]
            ]
    """
        |> String.replace "{{NAME}}" name
        |> String.replace "{{PROPS_TYPE}}" (Props.typeSig props)
        |> String.replace "{{PROPS_ENCODER}}" (Props.encoder props)
